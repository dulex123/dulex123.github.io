<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title></title>
    <link>http://dulex123.github.io</link>
    <description>
      Experimental software engineering.
    </description>
    
        
            <item>
                <title>Docked deep learning</title>
                <link>http://dulex123.github.io/posts/2017/02/09/docked-deep-learning/</link>
                <content:encoded>
                    <![CDATA[
                    <p><em>If you are tired of installing bloatware everytime you want to run a project that has dependencies, then Docker may be a solution for you!</em></p>

<hr />

<p>Docker allows you to isolate your new project environment from your host OS efficiently, something like virtualenv in python but more VM-like, but then again without the whole OS installation and massive resource consumption.</p>

<h2 id="theory">1. Theory</h2>

<p>So let’s start with easy docker concepts:</p>

<ul>
  <li>
    <p><strong>Container</strong><br />
All action happens within the container. When you want to run a script you run it from the inside of a container, if you want to install software, you run it inside the container. If your friend wants to try your software without wasting 14hrs on framework stack setup, you send him your container.</p>

    <p>So the container is an environment in which you can do whatever you want with no consequences to your host OS. And if you screw something up within a container? You just delete it, create another one (or 6, 10, 200) just like it and try again.</p>

    <p>So container idea as a separate entity should be clear by now. But what is within a container? What software is preinstalled? Which OS?</p>
  </li>
</ul>

<p>These questions lead us to <em>the image</em>.</p>

<ul>
  <li><strong>Image</strong>
Image is an immutable template that can be instantiated as a container. Something like this:</li>
</ul>

<p><img src="http://i.imgur.com/xZr1QfY.png" alt="Image container relationship" /></p>

<p>So once created, an image is immutable (changes during the lifetime of a container does not affect the image). It serves as a common ground for all containers it instantiates. Whatever you do is saved within a container, but container communicates with its image and all operations are going through the image. You need one image, and you can instantiate any number of containers.</p>

<p>How this helps is evident from the following:</p>

<p><em>If you had a 2GB VM, you would need 2GB x how many VMs you want. And that’s only disk space; there will be massive consumption of CPU, RAM and other resources you need. With Docker, much of that 2GB are shared between containers, and with 1000 containers you will get only a little over a 2GB space requirement. (If they are of the same image ofc) So for less isolation than an actual VM you are getting very lightweight containers.</em></p>

<p>Also, fully virtualized VM takes minutes to start where Docker container takes only seconds.</p>

<p>An alternative explanation of image and container relationship from OOP perception:<br />
  - Image is equivalent to a class in OOP whereas<br />
  - A container is equivalent to an object</p>

<p>But what defines an image? How is it created? - It comes from a  txt file called:</p>

<ul>
  <li>
    <p><strong>Dockerfile</strong>
Textual file on what to setup within an image that can later be instantiated as a container and used. You build docker image from dockerfile.</p>

    <p>The beautiful thing is that probably someone somewhere before you needed the same or similar stack and there are docker files for you just to download them. Even better, instead of building an image yourself (which depending on a dockerfile can last for quite some time), you can find them online at dockerhub or similar websites, download it, instantiate a container and start experimenting with your code.</p>
  </li>
</ul>

<p>Although containers are isolated, you can share folders between host OS and container, open network ports, etc., just as in regular VM.</p>

<h2 id="practice">2. Practice</h2>
<p>So let’s use all this information to create a suitable environment for a deep learning project. My host OS is Ubuntu 16.04 so that’s what I’ll use.</p>

<ul>
  <li>Step 0: Install docker and nvidia-docker
    <ul>
      <li><a href="https://docs.docker.com/engine/installation/linux/ubuntu/">Official docker installation</a></li>
      <li><a href="https://github.com/NVIDIA/nvidia-docker">Nvidia-docker</a> package is used to leverage GPU for anything you do inside container, you just need to have nvidia drivers installed on your host OS. It is not necessary, but for our application is very desirable. If you are not using GPU you don’t need this package. Everywhere you see nvidia-docker just type docker instead.</li>
    </ul>
  </li>
  <li>Step 1: Getting suitable dockerfile
    <ul>
      <li>
        <p>I’ve stumbled upon this great dockerfile repo <a href="https://github.com/floydhub/dl-docker">dl-docker</a>. It will install Ubuntu 14.04 with CUDA 8, cuDNNv5, Tensorflow, Caffe, Theano, Keras, Lasagne, Torch, iPython/Jupyter, Numpy-Scipy-Scikit learn-matplotlib on top of it.</p>

        <p>To get the dockerfile from github just type:</p>
      </li>
    </ul>

    <div class="highlighter-rouge"><pre class="highlight"><code><span class="gp">$ </span>git clone https://github.com/saiprashanths/dl-docker.git
<span class="gp">$ </span><span class="nb">cd </span>dl-docker
</code></pre>
    </div>
  </li>
  <li>Step 2: Build or download image
    <ul>
      <li>Since many images are available for download, you can directly download your image from a place like <a href="https://hub.docker.com/">dockerhub</a>. We are going to build our own image because currently there is no GPU image for dockerfile on dockerhub. Check the bottom of this page if you run into errors:</li>
    </ul>

    <div class="highlighter-rouge"><pre class="highlight"><code><span class="c"># Notice the dot at the end</span>
<span class="gp">$ </span>docker build -t floydhub/dl-docker:gpu -f Dockerfile.gpu .
</code></pre>
    </div>

    <p><em>There is an image on dockerhub without GPU support and we could download it without building</em></p>

    <div class="highlighter-rouge"><pre class="highlight"><code><span class="c"># We don't need this if we are using GPU</span>
<span class="gp">$ </span>docker pull floydhub/dl-docker:cpu
</code></pre>
    </div>
  </li>
  <li>Step 3: Instantiate a container
    <ul>
      <li>Now we will create our container with two network ports and one folder shared with the host OS.</li>
    </ul>

    <div class="highlighter-rouge"><pre class="highlight"><code>nvidia-docker run -it -p 8888:8888 -p 6006:6006 -v /sharedfolder:/root/sharedfolder floydhub/dl-docker:gpu bash
</code></pre>
    </div>

    <p>Parameter <strong>-p port1:port2</strong> maps port1 from host OS to port2 on container<br />
This means that whatever is launched on port2 inside container will show up in your host OS browser if you go to http://localhost:port1.</p>

    <p>Parameter <strong>-v folder1:folder2</strong> maps absolute path folder1 on host OS to folder2 on container. If you change anything in folder1 it will reflect inside of a container on folder2.</p>
  </li>
</ul>

<p>Once you create a container, you will get a root access to it (no need for users since it is isolated right?). When you finish your work, you can type exit, and it will save the container state and stop the container. You will probably want to use that container again so here are some commands that can be helpful:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c"># List all images</span>
<span class="gp">$ </span>sudo docker images

<span class="c"># List currently running containers</span>
<span class="gp">$ </span>sudo docker ps

<span class="c"># List all containers</span>
<span class="gp">$ </span>sudo docker ps -a

<span class="c"># Start some container</span>
<span class="gp">$ </span>sudo docker start &lt;container_name&gt;

<span class="c"># Connect to container (Attach to container terminal)</span>
<span class="gp">$ </span>sudo docker attach &lt;container_name&gt;

<span class="c"># Connect second terminal to container (or more)</span>
<span class="gp">$ </span>sudo docker <span class="nb">exec</span> -it &lt;container_name&gt; bash

<span class="c"># Remove a container</span>
<span class="gp">$ </span>sudo docker rm &lt;container_name&gt;

<span class="c"># Remove an image</span>
<span class="gp">$ </span>sudo docker rmi &lt;image_name&gt;

<span class="c"># You can use container_id instead of container_name</span>

</code></pre>
</div>

<p><strong>Note:</strong> I’ve said that you can ship containers to a friend. Although this is possible much more sensible thing to do would be for him to download/build an image and pull your project from a git repo, within the instantiated container.</p>

<p>You may also find useful this <a href="https://github.com/wsargent/docker-cheat-sheet/blob/master/README.md">beautiful cheatsheet</a> that has many
useful docker commands which can help your docker-fu.</p>

<h2 id="errors-while-building-the-image">Errors while building the image:</h2>

<ul>
  <li>
    <p>setup.py egg_info error can be solved with</p>

    <div class="highlighter-rouge"><pre class="highlight"><code>pip install <span class="nv">setuptools</span><span class="o">==</span>33.1.1
</code></pre>
    </div>
  </li>
  <li>
    <p>If you get an error with libopenjpeg2, the package is renamed to libopenjpeg5 so you just need to:</p>

    <div class="highlighter-rouge"><pre class="highlight"><code>sudo apt-get install libopenjpeg5
</code></pre>
    </div>
  </li>
</ul>


                    ]]>
                </content:encoded>
                <guid isPermaLink="false">/posts/2017/02/09/docked-deep-learning/</guid>
                <description>
                    
                    Avoid bloating your system with tons of dependencies.
                    
                </description>
                <pubDate>Thu, 09 Feb 2017 00:00:00 +0100</pubDate>
                <author>Душан Јосиповић</author>
            </item>
        
    
        
            <item>
                <title>Machine learning immersion</title>
                <link>http://dulex123.github.io/posts/2016/09/24/machine-learning-immersion/</link>
                <content:encoded>
                    <![CDATA[
                    <p><em>This page will be updated as I absorb more stuff.</em></p>

<h2 id="path-of-machine-learning">Path of Machine Learning</h2>
<p>So you have finally decided to immerse yourself in the world of machine learning. Congrats! Here is my list of material I consider very useful.</p>

<p>Staying up to date is very important for anything Computer Science related and is also true in the fast-evolving field of deep learning. So here are some of the latest educational materials.</p>

<p>-</p>

<h2 id="environment">Environment</h2>
<p>The easiest way to pick up the speed is to surround yourself with people that are in the field and are sharing information through social networks. If you don’t know where to start, have a look at my <a href="https://twitter.com/josipovicd/following">twitter list</a> and go to their sources. If most of it doesn’t make sense in the beginning that’s ok.</p>

<h2 id="online-courses">Online courses</h2>
<p><a href="https://www.coursera.org/learn/machine-learning">Coursera, Machine Learning</a><br />
Taught by fantastic Andrew Ng, this course provides a very nice introduction to the field of machine learning. You build all models yourself in Matlab/Octave. Especially useful is the course wiki that you are introduced to in Week 1. Highly recommended.</p>

<p><a href="http://academictorrents.com/details/46c5af9e2075d9af06f280b55b65cf9b44eb9fe7">Stanford, Convolutional Neural Networks for Visual Recognition</a><br />
Building upon what you learned previously, this course from January 2016 really gets you in the high gear where you delve deep into the nuts and bolts of CNNs, implementing networks every step of the way. There are also <a href="http://cs231n.github.io/">awesome notes and assignments</a> on the GitHub page of the course. Probably the best online course I have ever taken.</p>

<h2 id="the-book">The book</h2>
<p><a href="http://www.deeplearningbook.org/">Deep learning book</a>. Very well written book on important topics for neural network construction.</p>

<p>-</p>

<h2 id="something-i-am-about-to-dive-in">Something I am about to dive in</h2>
<p><a href="http://upwork.com">UpWork</a>
<a href="https://gym.openai.com/">OpenAI Gym</a>
<a href="https://www.kaggle.com/">Kaggle competitions</a><br />
Awesome places to further explore hot topics, meet people, sharpen your skills and make some money too!</p>

                    ]]>
                </content:encoded>
                <guid isPermaLink="false">/posts/2016/09/24/machine-learning-immersion/</guid>
                <description>
                    
                    First serious steps towards deep learning.
                    
                </description>
                <pubDate>Sat, 24 Sep 2016 00:00:00 +0200</pubDate>
                <author>Душан Јосиповић</author>
            </item>
        
    
        
            <item>
                <title>CompetitiveFlow</title>
                <link>http://dulex123.github.io/schemes/2016/06/08/Scripts-for-competitive-flow/</link>
                <content:encoded>
                    <![CDATA[
                    <h2 id="insane-habit-of-copy-pasting-tests">Insane habit of copy-pasting tests</h2>

<p>If you have done any competitive programming on codeforces you may have noticed that in those intense moments when the clock is ticking away and some new insight into problem strikes you, you start copy-pasting test problems into terminal. And if you do it for a few times it becomes an insane habit that can ruin your train of thought that may lead to a solution.</p>

<p>So after a few hours of tweaking I have made this pair of scripts that will allow you to test your solutions more easily. Check it out on <a href="https://github.com/dulex123/competitive-flow">Github</a></p>

<iframe width="640" height="400" src="https://www.youtube.com/embed/vFjqoGfHRBk" frameborder="0" allowfullscreen=""></iframe>

<h2 id="update">Update:</h2>

<p>After using competitive flow for a few rounds, I’ve got some new ideas that would be worth developing for even faster coding.</p>

<p>Features:</p>

<ul>
  <li>
    <p>Program connected to browser via extension with native support - this will enable the program to gather problem info without copying data</p>
  </li>
  <li>
    <p>Terminal-gui (<a href="https://en.wikipedia.org/wiki/Ncurses">Ncurses lib</a>) where a,b,c,d,e,f selects problem mode and 1,2,3,4.. runs particular test on it</p>
  </li>
  <li>
    <p>Run all tests / Submit command</p>
  </li>
  <li>
    <p>Init - initialize folder with separate files for each problem filled with boilerplate code</p>
  </li>
</ul>

                    ]]>
                </content:encoded>
                <guid isPermaLink="false">/schemes/2016/06/08/Scripts-for-competitive-flow/</guid>
                <description>
                    
                    Scripts for CodeForces competitive programming platform.
                    
                </description>
                <pubDate>Wed, 08 Jun 2016 00:00:00 +0200</pubDate>
                <author>Душан Јосиповић</author>
            </item>
        
    
  </channel>
</rss>
